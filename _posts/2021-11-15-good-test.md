---
layout: post
title:  "Characteristics of good automated tests"
date:   2021-11-10 09:47:57 +0100
categories: unit-testing, practices
---

When writing automated (unit?) tests, what do you consider to be a good test vs a bad test? When speaking to various people,
and reviewing a LOT of code, i'm finding that many people have different thoughts and idea's about this. 

I'm quite passionate about automated testing, so I figured I'd jot down my own thoughts here.  

> I started writing a completely different blog post.. Then from there, this post started to form.. then it became too big. WAY to big. So I cut it down so I can at least get something out. Hopefully, I'll be able to post the others soon as well. 

In this post, i'm talking about automated tests, but they apply equally well to unit tests, integration tests, UI tests, etc..

# Benefits of well written tests. 

We don't write tests 'just for fun', but because we believe that it brings certain important benefits. A good test helps you by:

1. Bringing you **increased understanding**. It helps you to write the code, or when reading the tests to understand what the code does. 
2. **Protects** you from mistakes during writing / changing / refactoring and bring you **confidence** in the correctness of the code. 
3. Making software development **faster**, not slowing you down. 

Looking at the inverse of these properties can also be interesting. A test should **not**: 
1. **Slow me down** when writing or maintaining code. If there's too much overhead in writing / maintaining / running the tests, they don't bring me any value. How you factor your code is important as well as at which level you start your tests.  
2. **Confuse me**: If you can't understand what a test does, how it does things or why it does things, it's usually not valuable at all. A big reason for this can be the use of mocking frameworks (more) about that in a follow up post. 
3. **undermine my trust**. If you can't trust your tests, they are not very valuable. This can happen when your tests don't catch mistakes made. Probably the coverage or assertions are not good enough to build trust. Another reason to undermine your trust is if they fail without good reason. The tests are too brittle then and, because I have to go in and modify my tests as well, i'm eroding the value that they bring. Flakey tests are the worst, when the tests occasionally fail, usually due to improper test isolation. *Looking at you, static mutable state!*

## Characteristics of good tests. 

So, what characteristics does a test need in order to bring you the benefits stated above. A test should:
1. have a clear **purpose**. Sometimes this might mean test a single thing (even if the single thing is a complex business scenario). The name of the test is important, but so is the way you write it. 
2. protect you from **real issues**. I'll probably write another blog post later about things not worth testing. 
3. be **quick to write**. By properly factoring your code, you can improve the speed at which you can write or maintain your tests. 
4. be **resilient** against internal changes (that have no impact on the actual logic or the api signature). 
5. be **easily changed** when changes to api signatures occur.
6. Be written at the **appropriate level** of technical complexity. Business oriented components have different requirements than more technical components. 
7. The **reason for failures** quickly clear. When a test fails, it's quickly clear why they fail, ideally without the need for debugging. I've often found printing log messages to the test output window. 
8. **Run quickly**. Yes, automated tests should run really really quick. I use a continuous test runner [NCrunch](https://www.ncrunch.net) to help me run the tests. It's great, try it. 

In a future post, I'll try to write more about how I typically structure my tests and what things to avoid. 

# Conclusion

With these characteristics, I've often found my tests to be easy to understand (at least to me), easy to maintain. 




